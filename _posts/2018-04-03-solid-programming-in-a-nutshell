---
layout: post
title: "SOLID programming in a Nutshell"
description: "SOLID programming in a Nutshell"
date: 2018-04-03
tags: [solid, programming]
comments: true
share: true
---

SOLID is an acronym for 5 design principles to turn software code more understandable, flexible and maintainable. Easier to extend, reuse

## S: Single responsibility

A class (or a function) should have only a single responsibility. Let's take a look on this class which register a customer:

```
class CustormerRegistration {
  registerCustomer();
  sendCustomerEmail();
}
```

A good exercise to identify if your class is doing more than one responsibility is thinking:

> "Is there more than one reason to change this class?"

If so probably this class is doing more than one responsibility. In this example, if rules how customer are being registered, or how we send mail (such as SMTP configuration) needs to be modified, the class need to change for both reasons.

To apply Single Responsibility we only need to split different responsibilities into classes:

```
class MailSender {
  send();
}

class CustormerRegistration {
  registerCustomer() {
    MailSender.send(customerEmail);
  }
}
```

Now each class has only single responsibility, and it becomes easier to understand the system, or find the piece of code which needs to be modified. Some problem at mail sending? Go straight to `MailSender`, and only this class will be changed!

Of course this also applies to functions. If you have a large function doing multiple stuff, divide into many functions each doing only one specialized thing!

In my experience this leads to a lot of classes having only one method being invoked by another classes (public methods) due single responsibility nature. If you have a class with multiple public methods, you can think twice too!

Benefits:
- The software code became easier to read and understand.
- Shorter, simpler and specialized classes and functions.
- Direct dependency (coupling) are reduced and clearer.
- Easier to find where code needs to be modified due changes or bugs.

## O: Open-closed

A class should be open to extension, but closed for modification. The basic idea is to implement a design which we can add new features without changing the existent code.

A good example is when we have multiple decisions to take to do something:

```
class Notification {
  notify(mode) {
    if(mode == 'SMS'){
      doSmsLogic()
    }

    if(mode == 'Email') {
      doEmailLogic()
    }
  }
}

Notification.notify('Email')
```

What happens if we need to also notify via `Mobile`? Yes, modify that code. Let's refactor this to be extensible instead:

```
class SMS {
  doNotificationLogic()
}

class Email {
  doNotificationLogic()
}

class Notification {
  notify(mode) {
    mode.doNotificationLogic()
  }
}

Notification.notify(Email)
```

Now if we want to notify via `Mobile`, we just need to create a `Mobile` class with a `doLogic()` method, without touching the existent code!

> Do we need always to apply this principle?

No, as you can see the code became extensible but more complex as well, while you are not sure there will be modifications in the future, stay simple. If someday appear new modifications and being extensible will be a good tradeoff, then you refactor and apply this principle.



Benefits:

- Code can be more maintainable and reusable.

## L: Liskov Substituition

Objects should be be replaceable by instances of their subtypes without changing the behavior.

Let's take a look on `Order` class and its subtype `SpecialOrder`:

```
class Order {
  sendProduct() {
    this.hasProductSent = true
  }
}

class SpecialOrder {
  sendProduct() {
    if(this.isSpecialClient) {
      this.hasProductSent = true
    }
  }
}
```

Basically this principle tell us if we invoke `SpecialOrder.sendProduct()` instead `Order.sendProduct()` shouldn't affect the behavior of the program, and as you can see the subtype `SpecialOrder` doesn't guarantee `this.hasProductSent` will be always true.

More than code, this principle is about behavior contract. If an object has a function to send a product, the subtypes should do the same. If your subtypes has more conditions then you are violating this principle. So let's refactor to apply Liskov Substituition Principle:

```
class Order {
  canSendOrder() {
    return true
  }

  tryToSendTheProduct() {
    if(this.canSendOrder()){
      this.hasProductSent = true
    }
  }
}

class SpecialOrder {
  canSendOrder() {
    return this.isSpecialClient
  }

  tryToSendTheProduct() {
    if(this.canSendOrder()){
      this.hasProductSent = true
    }
  }
}
```

Now the behavior is the same in both type and subtype. We also changed method the name `sendProduct()` to `tryToSendTheProduct()` only to reinforce the behavior change, and that's the actual contract between classes and subtypes.

In most of programming languages you can extend subtype by inherance or interfaces, then you could take advantage and declare `tryToSendTheProduct()` only once on the parent class and reuse on its subtypes, or you can also define a `Order` interface instead with `NormalOrder` and `SpecialOrder` subtypes.

Benefits:
- Easier to understand hierarchies or code contracts (interfaces)
- Subtypes behaviors isn't hidden or obscure
- Code may be reusable

## I: Interface Segregation

A class should depend upon only on things it actually needs. Seems just using common sense, right? It is, look at this example:

```
interface Product {
  getDeliveryAddress()
  getTaxes()
}

class InternationalProduct : Product {
  getDeliveryAddress() {
    return "International St."
  }

  getTaxes () {
    return "$ 3.20"
  }
}

class NationalProduct : Product {
  getDeliveryAddress() {
    return "National St."
  }

  getTaxes () {
    throw new FreeOfTaxesError()
  }
}
```

As we can see, there is no need to `NationalProduct` implements the `getTaxes()` method. It's a problem on design of interface. Let's refactor to apply Interface Segregation principle:

```
interface Product {
  getDeliveryAddress()
}

interface Taxable {
  getTaxes()
}

class InternationalProduct : Product, Taxable {
  getDeliveryAddress() {
    return "International St."
  }

  getTaxes () {
    return "$ 3.20"
  }
}

class NationalProduct : Product {
  getDeliveryAddress() {
    return "National St."
  }
}
```

Now each class has only implementation that really needs, and furthermore we have interfaces which describes better what product is.

Benfits:

- Code is less coupled (dependent)
- May be easier to refactor

## D: Dependency Inversion

High-level modules should not depend on low-level modules, they should depend on shared abstractions. Most of our objects don't work alone, they are dependent of other objects to achieve a tasks, however this principle is to minimize the direct dependency. Look at the current code:

```
class Amazon {
  buy() {
    return 'this was bought at Amazon'
  }
}

class PurchaseOrder {
  order() {
    new Amazon().buy()
  }
}

PurchaseOrder.order()
```

The high-level class `PurchaseOrder` is strict dependent of low-level `Amazon`. Applying the Dependency Inversion principle, this will looks like:

```
interface Store {
  buy();
}

class Amazon : Store {
  buy() {
    return 'this was bought at Amazon'
  }
}

class PurchaseOrder {
  order(store) {
    store.buy()
  }
}

PurchaseOrder.buy(Amazon)
```

Now `PurchaseOrder` is dependent of `Store` interface, not low-level `Amazon` class anymore.

If already heard about "Dependency Injection", it's an application of this principle, but still different things.
